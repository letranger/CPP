% Created 2021-11-21 Sun 13:11
% Intended LaTeX compiler: pdflatex

\documentclass[a4paper,12pt]{article}
\usepackage[margin=2cm]{geometry}

\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{multicol}
\usepackage{amssymb}
\tolerance=1000
\usepackage{listings}
\usepackage{titlesec}
\newcommand{\sectionbreak}{\clearpage}
\usepackage[scaled]{helvet}
\usepackage{courier}
\linespread{1.10}
\usepackage[margin=1.0in]{geometry}
\usepackage[numbers,sort&compress,square]{natbib}
\usepackage{glossaries}
\makeglossaries
\usepackage{setspace} \singlespacing
\usepackage{enumitem}
\setlist[itemize]{noitemsep, topsep=0pt}
\setlist[enumerate]{noitemsep, topsep=0pt}
\setlength\arrayrulewidth{0.7pt} % width of table line
\usepackage[english]{babel}
\addto\captionsenglish{\renewcommand\contentsname{Outline}}
\hypersetup{linktoc = all, colorlinks = true, urlcolor = DodgerBlue4, citecolor = PaleGreen1, linkcolor = black}
\usepackage[UTF8, heading]{ctex}
\usepackage{xltxtra}
\usepackage{xeCJK}
\usepackage{lmodern}
\usepackage{verbatim}
\usepackage{float}
\usepackage{tikz}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{textcomp}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{natbib}
\usepackage{fancyhdr}
\usepackage{fontspec,xunicode,xltxtra}
\usepackage{CJKnumb}
\usepackage{amsfonts}
\usepackage[default]{sourcecodepro}
\usepackage[T1]{fontenc}
\setCJKmainfont{SimSun} % 設置缺省中文字體
\setmainfont[Scale=0.8]{Times New Roman} % 英文襯線字體
\setsansfont[Scale=0.8]{Source Code Pro} % 英文無襯線字體
\setmonofont[Scale=0.8]{Source Code Pro} % 英文等寬字體
\setCJKmainfont[Scale=0.9]{Adobe Heiti Std} % 中文字體
\setCJKmonofont[Scale=0.9]{Adobe Heiti Std}
\usepackage{color}
\RequirePackage{fancyvrb}
\usepackage{placeins}
\hypersetup{pdfauthor={Name}}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{dred}{rgb}{0.545,0,0}
\definecolor{dblue}{rgb}{0,0,0.545}
\definecolor{lgrey}{rgb}{0.9,0.9,0.9}
\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\definecolor{bubbles}{rgb}{0.91, 1.0, 1.0}
\definecolor{foreground}{RGB}{220,220,204} % 淺灰
\definecolor{background}{RGB}{62,62,62} % 淺黑
\definecolor{preprocess}{RGB}{250,187,249} % 淺紫
\definecolor{var}{RGB}{239,224,174} % 淺肉色
\definecolor{string}{RGB}{154,150,230} % 淺紫色
\definecolor{type}{RGB}{225,225,116} % 淺黃
\definecolor{function}{RGB}{140,206,211} % 淺天藍
\definecolor{keyword}{RGB}{239,224,174} % 淺肉色
\definecolor{comment}{RGB}{180,98,4} % 深褐色
\definecolor{doc}{RGB}{175,215,175} % 淺鉛綠
\definecolor{comdil}{RGB}{111,128,111} % 深灰
\definecolor{constant}{RGB}{220,162,170} % 粉紅
\lstdefinelanguage{cpp}{ %%定義語言style
backgroundcolor=\color{bubbles},
basicstyle=\footnotesize \ttfamily \color{dblue},
breakatwhitespace=false,
breaklines=true,
captionpos=b,
comment=[l]{\#},
morecomment=[s]{/*}{*/},
commentstyle=\color{comment} \slshape \small \itshape,
ndkeywords={print, printf, repeat, struct, enum, case, switch, func, let, var, boolean, throw, import, typeof, null, catch, switch, for, in, int, str, float, self, return, class, if ,elif, endif, while, do, else, True, False , catch, def},
ndkeywordstyle=\color{dred} \bfseries \small \mono,
identifierstyle=\color{black},
deletekeywords={...},
escapeinside={\%*}{*)},
frame=single,
frameround=tttt,
framesep=0pt,
rulecolor=\color{background},
morekeywords={BRIEFDescriptorConfig,string,TiXmlNode,DetectorDescriptorConfigContainer,istringstream,cerr,exit},
identifierstyle=\color{black},
stringstyle=\color{blue},
rulecolor=\color{black},
showspaces=false,
showstringspaces=false,
showtabs=true,
stepnumber=1,
tabsize=5,
title=\lstname,
}
\lstdefinelanguage{shell}{
backgroundcolor=\color{keyword},
basicstyle=\footnotesize \ttfamily \color{dblue} \small \mono \bfseries,
breakatwhitespace=false,
breaklines=true,
captionpos=b,
comment=[l]{\#},
morecomment=[s]{/*}{*/},
commentstyle=\color{comment} \slshape \small \itshape,
identifierstyle=\color{black},
deletekeywords={...},
escapeinside={\%*}{*)},
frame=single,
frameround=tttt,
framesep=0pt,
rulecolor=\color{background},
morekeywords={BRIEFDescriptorConfig,string,TiXmlNode,DetectorDescriptorConfigContainer,istringstream,cerr,exit},
identifierstyle=\color{black},
stringstyle=\color{blue},
rulecolor=\color{black},
showspaces=false,
showstringspaces=false,
showtabs=false,
stepnumber=1,
tabsize=5,
title=\lstname,
}
\author{Yung Chin, Yen}
\date{\today}
\title{Basic Materials of C++}
\begin{document}

\maketitle
\tableofcontents

\newpage

\section{程式的編寫與執行}
\label{cpp_execution}
\subsection{source code}
\label{sec:org3d9b562}
所謂的程式碼基本上都只是一些文字檔，只是這些文字的撰寫是依照不同語言(如 C、C++、Python、R\ldots{})所規定的語法(syntax)來撰寫，以達到特定目的。\\

\subsection{編寫}
\label{sec:org0c1f780}
既然程式碼只是文字檔，所以，其實我們可以很單純的以 windows 的記事本或是 MacOS 中的 TextEdit 來編寫各種語言的程式碼，只是，使用這些應用程式來編寫程式會相對辛苦，因為相對於一些專用的應用程式如 DevC++、VSCode、PyCharm 等都會提供撰寫者許多的額外功能，例如即時除錯、自動縮排、自動補完(auto complete)，甚至是後續的編譯、執行..。\\

\subsection{編譯與執行}
\label{sec:org23623c1}
既然寫完的程式碼只是文字檔，那這些文字檔要如何變成可以執行的執行檔呢？\\
如下圖\footnote{\href{http://www2.lssh.tp.edu.tw/\~hlf/class-1/lang-c/compile.htm}{程式編譯過程}\\}所示：\\

\url{images/c\_compile.gif}\\

程式碼必須先經過 Preprocess、Compile、Assemble、Link 等步驟才能成為一支可以執行的執行檔(如 Windows 下的.exe 或是 MacOS 下的.app)。\\

\subsection{幾種寫程式的環境}
\label{sec:orgd99603b}
\begin{enumerate}
\item MacOS
\label{sec:org5c7acfd}
\begin{itemize}
\item \href{https://developer.apple.com/xcode/}{Xcode}\\
\end{itemize}
\item Windows
\label{sec:org9847af4}
\begin{enumerate}
\item DevC++
\label{sec:orgaf27806}
\begin{itemize}
\item \href{https://progressbar.tw/posts/7}{[C語言] 01. Dev C++ 程式編輯器，大一理工學院新生惡夢的開始。}\\
\item \href{http://selfinquiring.hatenablog.com/entry/2016/03/18/204352}{Nova的科學反主流學院　}\\
\end{itemize}
\item Code::Blocks
\label{sec:orga273dfa}
\begin{itemize}
\item \href{https://blog.csdn.net/DongChengRong/article/details/78624068}{安裝BlockCode}\\
\item \href{https://mks.tw/1053/cc-codeblocks-\%E8\%BC\%95\%E5\%B7\%A7\%E7\%9A\%84\%E6\%95\%B4\%E5\%90\%88\%E5\%BC\%8F\%E9\%96\%8B\%E7\%99\%BC\%E7\%92\%B0\%E5\%A2\%83}{[C/C++] Code::Blocks 輕巧的整合式開發環境}\\
\end{itemize}
\item Visual Studio Code
\label{sec:orgd99dfeb}
\begin{itemize}
\item \href{https://blog.csdn.net/HelloZEX/article/details/84029810}{【VS】VS Code安装、配置、使用（windows10 64）}\\
\item \href{https://tw.alphacamp.co/blog/visual-studio-code-editor-tutorial-and-extensions}{VSCode快速安裝教學，推薦常用外掛擴充套件}\\
\end{itemize}
\end{enumerate}
\item 線上 coding 環境
\label{sec:org7e1540d}
\begin{itemize}
\item \href{http://cpp.sh/}{cpp.sh}\\
\item \href{https://www.jdoodle.com/online-compiler-c++/}{JDOODLE}\\
\item \href{https://repl.it/languages/cpp}{repl.it}\\
\item \href{https://code.sololearn.com/\#cpp}{SOLOLEARN}\\
\end{itemize}

\newpage
\end{enumerate}

\section{C++基本架構}
\label{cpp_arch}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;

int main()
{
    cout << "Hello world\n";
    return 0;
}
\end{lstlisting}

\begin{verbatim}
Hello world
\end{verbatim}
\subsection{main()}
\label{sec:org5cd5337}
C/C++的程式由許多的 function(函式)組成，function 的基本架構如下：\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
傳回值類型 函式名稱() {
    函式內容
    retrun 傳回值
}
\end{lstlisting}
前述程式中的第4行開始即為一名為 main 的 function，這也是 C/C++程式最主要的一支 function，程式被執行時，就由整支程式中找出名為 main 的 function 開始執行。之後我們的程式也將依序寫在這組大括號中。\\

\subsection{標頭檔(Headers)}
\label{sec:orgb644081}
上述程式中，第1行為標頭檔(Header)的引入，這裡告訴 Compiler 說我需要用到 iostream 這個 header，原因是程式的第6行用到 cout 這個指令，而這個指令就被定義在 iostream 這個 header 中，其中的 io 即代表 input/output。\\

往後如果用到其他函數，也需要 include 相關的 header，例如，如果需要用到數學的開根號函式 sqrt()，就需要 include math.h 這個 header，如下例中的第1行。\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
#include <math.h>
using namespace std;

int main()
{
    cout << sqrt(100) << endl;
    return 0;
}

\end{lstlisting}

\begin{verbatim}
10
\end{verbatim}
\subsection{命名空間(namespace)}
\label{sec:org0583639}
一支程式往往會用到許多的指令、函式、變數，不同單位所開發的程式也許會用到相同的名稱來為這些函式或變數命名，如此一來就可能導致名稱的衝突。舉個例子，在一年級新生中，有三個班級裡都有個叫*陳宜君*的同學，那麼我們怎麼區分這三位同學呢？一個方式在提及這些同學時在前面加上班級，如：一年三班的陳宜君。\\

C++就提出這種方式來解決名稱可能衝突的問題，以下面程式為例：\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
int main() {
    std::cout << "每次用到cout都指定namespace";
    return 0;
}
\end{lstlisting}

\begin{verbatim}
每次用到cout都指定namespace
\end{verbatim}


上例的第3中的 std::就是 C++的標準命名空間，用來說明這裡所用的 cout 是 C++預設的指令，但是如果你並沒有命名衝突的問題，其實可以一開始就直接把 namespace 設定為 std，如下面程式中的第2行。\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    cout << "用到cout時不用再特別指定namespace";
    return 0;
}
\end{lstlisting}

\begin{verbatim}
用到cout時不用再特別指定namespace
\end{verbatim}


有關於 namespace 的詳細說明，可參考\href{https://openhome.cc/Gossip/CppGossip/Namespace.html}{簡介名稱空間}以及\href{https://stackoverflow.com/questions/37693999/use-a-function-in-different-file-and-different-namespace-in-visual-c}{Use a function in different file and different namespace in Visual C++}這兩篇文章。\\
\newpage

\section{輸出}
\label{cpp_output}
顧名思意，輸出是將資料輸出到某種設備（如螢幕、印表機\ldots{}）, 常見的輸出指令有 cout、printf()、puts()、putchar()等。\\
\subsection{cout}
\label{sec:orgff408ef}
cout 為 iostream 這個類別(class)的 object\footnote{\href{https://www.quora.com/Is-cout-an-object-or-a-function-Why}{Is cout an ojbect or a function? Why?}\\}，所以程式中若使用到 cout 就必須 include iostream。cout 可以將文字資料與變數資料列印在螢幕上，在語法上會使用<<作為文字與變數之間的連接工具，若要換行則使用``\n''或是關鍵字 endl\footnote{\href{http://rs2.ocu.edu.tw/\~jengchi/IO\_instruction.htm}{Dev C++的輸出與輸入方法}\\}。\\

如果要輸出的是文字資料，則應該在文字的前後各加上英文的雙引號(``)，如下列程式的第4行，不同類型的數值資料間要以<<間隔。\\

\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    cout << "Hello world\n";
    cout << "半徑：" << 3 << endl;
    cout << "圓面積：" << 3*3*3.1416 << "\n";
    return 0;
}
\end{lstlisting}

\begin{verbatim}
Hello world
半徑：3
圓面積：28.2744
\end{verbatim}

\subsection{printf()}
\label{cpp_printf}
printf()為定義在 stdio.h 中的一個 function，所以若用到 printf()就要 include stdio.h。\\

和 cout 一樣，printf()一樣是用來進行資料的輸出，只是在輸出時提供了更多的格式選定選項。基本的應用如下例，更複雜的應用則在介紹完變數(vairalbe)概念後再行說明。\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}

#include <stdio.h>
using namespace std;
int main() {
    printf("Hello world\n");
    printf("半徑：%d\n", 3);  //%d表示在該處要顯示/輸出一個整數
    printf("圓面積：%.2f\n", 3*3*3.1416); //%.2f: 表示在該處要顯示/輸出一個小數，精確度達到小點點後第二位
    return 0;
}
\end{lstlisting}

\begin{verbatim}
Hello world
半徑：3
圓面積：28.27
\end{verbatim}

\subsection{跳脫字元}
\label{sec:org2daab1e}
如果你試過利用 C++來輸出下列這段話：\\
\begin{verse}
他說：``好''，然後他就死了。\\
\end{verse}
你會發現這是件困難的事，在前節的 cout 中，我們提及雙引號是用來將文字括起來的符號，若在字串中也出現雙引號，則勢必會打亂雙引號在文字中的規則。要輸出這類特殊字元的問題，有以下兩種方法：\\
\begin{enumerate}
\item cout + 單引號
\label{sec:org3159465}
以兩個單引號將雙引號括起來，如下列程式。\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    cout << "他說："<< '"' << "好" << '"' << "，然後他就死了。\n";
}
\end{lstlisting}

\begin{verbatim}
他說："好"，然後他就死了。
\end{verbatim}
\item 加上跳脫字元
\label{sec:org3160745}
即，在字串中的雙引號前加上$\backslash$，變成$\backslash$``，如下\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    cout << "他說：\"好\"，然後他就死了。\n";
}
\end{lstlisting}

\begin{verbatim}
他說："好"，然後他就死了。
\end{verbatim}


常用的跳脫字元還有以下幾類：\\
\begin{center}
\begin{tabular}{ll}
字元 & 意義\\
$\backslash$' & 單引號\\
$\backslash$`` & 雙引號\\
$\backslash$\ & 反斜線\\
$\backslash$0 & 空字元(NULL)\\
\t & 定位字元(TAB)\\
\n & 換行字元(ENTER)\\
\end{tabular}
\end{center}
\end{enumerate}

\section{Variable}
\label{cpp_variables}
\subsection{關於變數}
\label{sec:org0c794d3}
A variable is a name given to a memory location. It is the basic unit of storage in a program\footnote{\href{https://www.geeksforgeeks.org/variables-in-c/}{Variables in C++}\\}.\\
\begin{itemize}
\item The value stored in a variable can be changed during program execution.\\
\item A variable is only a name given to a memory location, all the operations done on the variable effects that memory location.\\
\item In C++, all the variables must be declared before use.\\
\end{itemize}

\subsection{\label{VarDec}變數的宣告與應用}
\label{sec:org70830e7}
變數是資料的標籤，而非資料本身。電腦程式很大一部分是在操作資料，變數在本質上是用來操作資料的一種語法特性。\footnote{\href{https://michaelchen.tech/c-programming/variable/}{宣告和使用變數 (Variable)}\\}\\
\begin{figure}[htbp]
\centering
\includegraphics[width=400]{images/Variables-in-C-1.jpg}
\caption{\label{fig:vic}Variables in C++}
\end{figure}

C 語言的變數宣告語法如下：\\
\lstset{breaklines=true,language=:eval,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
變數類型 變數名稱[=初值];
\end{lstlisting}
以下列程式為例，第4行宣告了一個名為 r 的整數型態(int)變數，這意謂著向記憶體要了塊足以儲存整數資料的空間，並將之命名為 r，並在第6將整數 5 存入這個空間中，爾後只要在程式中提及 r，指的便是 5 這個值。這裡的等號運算子其作用為指定(assign)，即是將等號*右邊*的值存入等號*左邊*的變數(空間)中。\\

在第5行宣告了一個名為 cirArea 的小數變數，接下來在第7行先計算出圓面積的值，再把這個值存入這個小數變數空間中。\\
\lstset{breaklines=true,language=C++,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    int r;
    double cirArea;
    r = 5;
    cirArea = r * r * 3.1416;
    cout << "圓面積：" << cirArea << endl;
}
\end{lstlisting}

\begin{verbatim}
圓面積：78.54
\end{verbatim}

\subsection{變數的命名規則}
\label{sec:org2e13425}
\begin{enumerate}
\item 可用字母、數字、底線。\\
\item 第一個字不可為數字，如 1x, 2x\ldots{}，可以為 x1, x2\ldots{}。\\
\item 名稱間不可有空白。如 student no，可以 student\textsubscript{Id} 或是 studentId 取代。\\
\item 大小寫有別(Case-Sensitive): a 與 A 為兩個不同的變數。\\
\item 不可使用關鍵字(如 int, double, if, while\ldots{})。\\
\item 底線開頭接大寫字母應保留給系統使用。\\
\end{enumerate}
更詳細的命名規範與建議可參閱：\href{https://www.itread01.com/content/1541214186.html}{C語言中變數名及函式名的命名規則與駝峰命名法}。\\

\subsection{變數類型}
\label{cpp_variable_types}
前節介紹了變數的宣告要先說明其類型，根據要儲存的資料種類不同，C++變數有許多型態。以下是一些常用的基本型態\footnote{\href{https://www.csie.ntu.edu.tw/\~b98902112/cpp\_and\_algo/cpp/variable\_type\_and\_declare.html}{變數型態}\\}：\\
\begin{center}
\begin{tabular}{llll}
型態 & 中文意思 & 英文字義 & 可儲存的資料\\
int & 整數 & Integer & 100、-5、1246 \ldots{}\\
float & 32 bit 單精浮點數(小數) & single precision floating point & 3.14159、4.3、-1.1 \ldots{}\\
double & 64 bit 倍精浮點數(小數) & double precision floating point & 3.14159、4.3、-1.1 \ldots{}\\
char & 字元(半形字) & Character & 'a'、'R'、'1'、'@'、'*' \ldots{}\\
string & 字串(文句) & String & ``Hello''、``\^{}\_\^{}''、``Rock!'' \ldots{}\\
bool & 布林(是非) & boolean & true、false\\
\end{tabular}
\end{center}
關於 float 與 double 的進一步說明，可參閱：\href{https://taichunmin.pixnet.net/blog/post/27827769}{float跟double小知識}。\\

\subsection{變數的極限}
\label{sec:orgd33a2b8}
\begin{enumerate}
\item 範例
\label{sec:orgd91b97d}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
#include <float.h>
using namespace std;
int main() {
    cout << INT_MIN << endl;
    cout << INT_MAX << endl;
    cout << LONG_MIN << endl;
    cout << LONG_MAX << endl;
    cout << DBL_MIN << endl;
    cout << DBL_MAX << endl;
}
\end{lstlisting}

\begin{verbatim}
-2147483648
2147483647
-9223372036854775808
9223372036854775807
2.22507e-308
1.79769e+308
\end{verbatim}

\item 詳細內容：
\label{sec:org7258fc3}
\url{https://en.cppreference.com/w/c/types/limits}\\
\end{enumerate}

\section{輸入}
\label{cpp_input}
\subsection{變數的輪入}
\label{sec:org7b49fd1}
前節提及變數的宣告、指定內容以及輸出變數，然而在程式內容中指定變數值實在很沒有彈性，我們可以透過輸入(cin)的方式將指定變數值的時機延後到程式執行時，由使用者來指定，例如：\\

\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    double r;
    double area;
    cin >> r;
    area = r * r * 3.14;
    cout << "半徑 " << r << "的圓，其面積為: " << area << "\n";
}
\end{lstlisting}

程式在執行至第6行中的 cin 時會暫停，等待使用者自鍵盤輸入一數值，並將該數值存入變數 r 中，接下來再以這個 r 來計算圓面積(第7行)，最後輸出其面積。\\

\subsection{一個以上的變數輸入}
\label{sec:org65c97c0}
如果要輸入多個變數，可以採以下兩種方式(類似 cout 的做法)\\
\begin{enumerate}
\item 分開 cin
\label{sec:org74e6dcf}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
//...
int x, y, z;
cin >> x;
cin >> y;
cin >> z;
//...
\end{lstlisting}

\item 以>>串接
\label{sec:org4038ad1}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
//...
int x, y, z;
cin >> x >> y >> z;
//...
\end{lstlisting}
\end{enumerate}

\section{運算式}
\label{cpp_operation}
\subsection{指定運算}
\label{sec:orgf184405}
最基本的運算子為=(assign)，即，將資料(數值、字元或字串)存入某變數空間中，如:\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    int x, y, z;
    x = 3;
    y = 4;
    z = x + y;
    cout << z << endl;
    x = 10;
    z = x + y;
    cout << z << endl;
}

\end{lstlisting}

\begin{verbatim}
7
14
\end{verbatim}


指定運算除了可以將其他變數的計算結果存入變數中(如上述程式中的第7、10行)外，也可以將變數本身的值再運算後存回來，如：\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    int x;
    x = 3;
    cout << x << endl;
    x = x + 1;
    cout << x << endl;
    x++; // 同x = x + 1
    cout << x << endl;
    x = x * 3;
    cout << x << endl;
}

\end{lstlisting}

\begin{verbatim}
3
4
5
15
\end{verbatim}


如同\ref{VarDec}所述:\\
\begin{verse}
等號運算子其作用為指定(assign)，即是將等號*右邊*的值存入等號*左邊*的變數(空間)中\\
\end{verse}
，上述程式中的第7行是先求出 x+1 的值(4)，再將這個值存回變數 x 中，這個運算也可以第9取代；同理，程式中的第11行是先將 x 的值乘以 3，再把結果存回變數 x 中。\\

\subsection{數值運算}
\label{sec:org586e612}
C/C++的基本數值運算有+、-、*、/、\%，最後的\%為取餘數。\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    int x = 10, y = 3;
    cout << x + y << endl;
    cout << x - y << endl;
    cout << x * y << endl;
    cout << x / y << endl;
    cout << x % y << endl;
}
\end{lstlisting}

\begin{verbatim}
13
7
30
3
1
\end{verbatim}


此處須留意的是第8行的值為整除的結果(得到商)，因為 x 與 y 均為整數，故此處的/為整除；此外，第9的\%運算僅能用於 x 與 y 均為整數的狀況，在 C/C++中，小數不允許有取餘數的運算(python 可以)。\\

數除運算也可以結合小括號來進行更複雜的運算，如：\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
//...
int t = 10;
double up = 10.3;
double bt = 20.4;
double height = 15;
double area;
area = ((up + bt) * height / 2) * 10;
// ...
\end{lstlisting}

此處須留意，小刮號可以層層相叠，但不能像數學式那樣最內層為小括號、然後是中刮號、大刮號\ldots{}\\

\begin{enumerate}
\item 進階運算
\label{sec:orgfd9cfd6}
C++也提供一些較複雜的數學運算如開根號、log、或是sin、cos等，但使用時必須include函式庫(math.h)\\
\begin{itemize}
\item 開根號\\
\end{itemize}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
#include <stdio.h>
#include <math.h> //一定要匯入
using namespace std;

int main() {
    int n;
    double ans;
    n = 10;
    ans = sqrt(n);
    cout << ans << endl;
    printf("%.2f\n", ans);
}
\end{lstlisting}

\begin{verbatim}
3.16228
3.16
\end{verbatim}
\end{enumerate}

\subsection{關係運算}
\label{cpp_cond_operation}
即，比較兩個值(或運算式)的結果，可的關係運算子如下：\\
\begin{center}
\begin{tabular}{lllr}
關係運算子 & 意義 & 使用範例 & 範例運算結果\\
== & 等於 & 1+1 == 2 & 1\\
!= & 不等於 & 3 != 4 & 1\\
> & 大於 & 5 > 7 & 0\\
>= & 大於等於 & 3 >= 5 & 0\\
< & 小於 & 2 < 6 & 1\\
<= & 小於等於 & 8 <= 8 & 1\\
\end{tabular}
\end{center}

\subsection{條件運算}
\label{sec:orgfdaba84}
上述關係運算所得的條件值(true/false)也可以再進行運算，而運算的結果也只有兩類: true/false。最基本的條件運算有以下三項：\\
\begin{enumerate}
\item \&\&, and
\label{sec:org85b4e5a}
且，只有在兩項條件均成立時其運算結果才是 true，否則其結果為 false，如\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    int x = 3;
    int y = 4;
    cout << (x >= 3 && y >= 0) << endl;
    cout << (x == 3 && y > 4) << endl;
}
\end{lstlisting}

\begin{verbatim}
1
0
\end{verbatim}

\item ||, or
\label{sec:orgd84c92e}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    int x = 3;
    int y = 4;
    cout << (x >= 3 || y < 0) << endl;
    cout << (x != 3 && y > 14) << endl;
}
\end{lstlisting}

\begin{verbatim}
1
0
\end{verbatim}

\item !, not
\label{sec:orgb585119}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    int x = 3;
    int y = 4;
    cout << !(x >= 3) << endl;
    cout << !(x == 3 && y > 4) << endl;
}
\end{lstlisting}

\begin{verbatim}
0
1
\end{verbatim}


如果數值運算，條件運算也結合小刮號進行更複雜的計算。\\
\end{enumerate}

\section{if 條件判斷}
\label{cpp_ifelse}
if 判斷式可用來判斷條件是否成立，並且依照條件之成立與否，來執行不同的程式碼\footnote{\href{https://crmne0707.pixnet.net/blog/post/285395384-c\%2B\%2B\%E5\%9F\%BA\%E7\%A4\%8E\%E6\%95\%99\%E5\%AD\%B8\%E8\%88\%87\%E7\%AF\%84\%E4\%BE\%8B--https://crmne0707.pixnet.net/blog/post/285395384-c\%2B\%2B\%E5\%9F\%BA\%E7\%A4\%8E\%E6\%95\%99\%E5\%AD\%B8\%E8\%88\%87\%E7\%AF\%84\%E4\%BE\%8B--\%283\%29if\%E5\%88\%A4\%E6\%96\%B7\%E5\%BC\%8F\%E8\%88\%87\%E9\%82\%8F\%E8\%BC\%AF\%E9\%81\%8B\%E7\%AE\%97\%E5\%AD\%90}{C++基礎教學與範例--(3)if判斷式與邏輯運算子}\\}。依照條件的複雜程度可大致分為以下三類：\\

\subsection{單一條件}
\label{sec:org195ae2c}
\begin{enumerate}
\item 語法
\label{sec:org042cc73}
最簡單型式的條件式如下，即，當條件成立，則執行程式碼。\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (條件) {
    程式碼;
}
\end{lstlisting}

\item 範例
\label{sec:org6faba50}
若分數及格，則輸出 PASS\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
  int score;
  score = 87;
  if (score >= 60) {
      cout << "PASS\n";
  }
}
\end{lstlisting}

\begin{verbatim}
PASS
\end{verbatim}

\item 課堂練習
\label{CPP_ifelse_practice1}
\begin{enumerate}
\item A: 輸入一整數，判斷正負，輸出結果。
\label{sec:org4a141b9}
\begin{enumerate}
\item 測資 1
\label{sec:orgfcef482}
\begin{itemize}
\item 輸入: 3\\
\item 輸出: 3>0\\
\end{itemize}
\item 測資 2
\label{sec:org014645b}
\begin{itemize}
\item 輸入: -4\\
\item 輸出: -4<0\\
\end{itemize}
\end{enumerate}
\item B: 輸入一整數，判斷奇偶，輸出結果。
\label{sec:org290b754}
\begin{enumerate}
\item 測資 1
\label{sec:org2b2e5fe}
\begin{itemize}
\item 輸入: 3\\
\item 輸出: The number 3 is odd.\\
\end{itemize}
\item 測資 2
\label{sec:org7f69a42}
\begin{itemize}
\item 輸入: -4\\
\item 輸出: The number -4 is even.\\
\end{itemize}
\end{enumerate}
\end{enumerate}
\end{enumerate}

\subsection{條件運算(條件的組合)}
\label{sec:org0846d26}
在前節的範例中，我們看到的是最簡單的條件，如\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
if (score >= 60) {
    ...
}
\end{lstlisting}
然而，更多時候我們要處理的是多種條件的組合，例如：輸入一分數，若所輸入的分數不合理(大於 100 或小於 0)，則輸出``請重新輸入''。雖然我們可以利用以下的寫法來解決問題：\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
  int score;
  score = -19;
  if (score < 0) {
      cout << "請重新輸入\n";
  }
  if (score > 100) {
      cout << "請重新輸入\n";
  }
}
\end{lstlisting}
但更適合的是利用條件運算來處理問題，如下：\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
  int score;
  score = -19;
  if ((score < 0) || (score > 100)) {
      cout << "請重新輸入\n";
  }
}
\end{lstlisting}

\begin{verbatim}
請重新輸入
\end{verbatim}


上述的||即為條件運算子，代表 OR。\\

C++的條件運算子列表如下：\\
\begin{center}
\begin{tabular}{llll}
運算子 & 名稱 & 範例 & 說明\\
\&\& & AND & ( 條件 1 \&\& 條件 2) & 當條件 1、2 皆成立時才算成立\\
\(\vert{} \vert{}\) & OR & ( 條件 1 \(\vert{} \vert{}\) 條件 2) & 只要條件 1、2 有一項成立就算成立\\
! & Not & !（條件 1) & 當條件 1 不成立時就成立\\
\end{tabular}
\end{center}

\subsection{雙重條件}
\label{sec:orgcdff382}
\begin{enumerate}
\item 語法
\label{sec:orge1fca6d}
若條件的可能性可分為兩類，則可使用如下 if..else..的條件式，即:\\
\begin{itemize}
\item 當條件成立，則執行程式碼一，\\
\item 否則(若條件不成立)，則執行程式碼二。\\
\end{itemize}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (條件) {
    程式碼一;
} else {
    程式碼二;
}
\end{lstlisting}

\item 範例
\label{sec:org034850b}
若分數及格，則輸出 PASS，否則輸出 FAIL\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
  int score;
  score = 57;
  if (score >= 60) {
      cout << "PASS\n";
  } else {
      cout << "FAIL\n";
  }
}
\end{lstlisting}

\begin{verbatim}
FAIL
\end{verbatim}
\item 課堂練習
\label{sec:org639602f}
\begin{enumerate}
\item A: 輸入一元二次方程式 \(ax^2+bx+c=0\) 中的 a,b,c 三參數，判斷此方程式是否有實數解，若有，則輸出 X exists.；若無實數解，則輸出 X does not exist.
\label{sec:org964ab84}
\begin{enumerate}
\item 測資 1
\label{sec:org881f393}
\begin{itemize}
\item 輸入: 1 3 -10\\
\item 輸出: X exists.\\
\end{itemize}
\item 測資 2
\label{sec:org00bb899}
\begin{itemize}
\item 輸入: 1 2 3\\
\item 輸出: X does not exist.\\
\end{itemize}
\end{enumerate}
\end{enumerate}
\end{enumerate}

\subsection{巢狀條件}
\label{sec:org784a727}
上節中提及若 if 後的件條成立，則執行大括號中的程式碼，此段程式碼也可以是 if 條件本身，如：\\
\begin{enumerate}
\item 語法
\label{sec:org470b48a}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (條件1) {
    程式碼...;
    if (條件2) {
        程式碼...;
    }
    程式碼...;
} else {
    程式碼...;
}
\end{lstlisting}
\item 範例
\label{sec:org08f3740}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    int pass;
    cin >> pass;
    bool userIsAdmin = true;
    if (pass == 1234) {
        if (userIsAdmin == true) {
            cout << "管理者，有root權限";
        } else {
            cout << "為一般使用者，權限有限";
        }
    } else {
        cout << "輸入密碼錯誤";
    }
}
\end{lstlisting}

\begin{verbatim}
輸入密碼錯誤
\end{verbatim}

\item 課堂練習
\label{sec:org9df117a}
\begin{enumerate}
\item A: 輸入一分數，若該分數合理(介於 0\textasciitilde{}100 間`)，則繼續判斷是否及格，若及格則輸出 PASS，若不及格則輸出 FAIL；若該分數不合理，則輸出: Invalid score。
\label{sec:orgf57987f}
\begin{enumerate}
\item 測資 1
\label{sec:orge744b5e}
\begin{itemize}
\item 輸入: 30\\
\item 輸出: FAIL\\
\end{itemize}
\item 測資 2
\label{sec:org84cb0ea}
\begin{itemize}
\item 輸入: 300\\
\item 輸出: Invalid score\\
\end{itemize}
\item 測資 3
\label{sec:org2ac9996}
\begin{itemize}
\item 輸入: 99\\
\item 輸出: PASS\\
\end{itemize}
\end{enumerate}
\end{enumerate}
\end{enumerate}

\subsection{多重條件}
\label{cpp_multi_conditions}
\begin{enumerate}
\item 語法
\label{sec:orgcb123bf}
\begin{itemize}
\item 當要判斷的條件可能性超過兩種，則可以用如下的 if..else if..條件式，即，\\
\item 當條件一成立，則執行程式碼一；\\
\item 若條件一不成立，則繼續判斷條件二，若條件二成立，則執行程式碼二；\\
\item 若條件二也不成立，則繼續判斷條件三\ldots{}依此類推。\\
\item 最後的 else(第else行則可有可無，若有，則表示如果以上所有條件皆不成立，則執行程式碼 N。\\
\end{itemize}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (條件一) {
    程式碼一;
} else if (條件二) {
    程式碼二;
} else if (條件三) {
    程式碼三;
} ... {

} else {               (else)
    程式碼N
}
\end{lstlisting}
\item 範例
\label{sec:orgd5e4b5c}
將分數轉成等第(A, B, C\ldots{})\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    int score = 79;
    if (score >= 90) {
        cout << "A\n";
    } else if (score >= 80) {
        cout << "B\n";
    } else if (score >= 70) {
        cout << "C\n";
    } else if (score >= 60) {
        cout << "D\n";
    } else {
        cout << "F\n";
    }
}
\end{lstlisting}

\begin{verbatim}
C
\end{verbatim}
\end{enumerate}

\section{For Loops}
\label{cpp_for_loop}
計算機的優勢除了運算速度之快，更重要的是它十分適合拿來做一些重複性極高的工作，例如，幫所有同學計算月考平均、幫全國所有家庭計算須繳所得稅\ldots{}.，For 迴圈即是許多語言用來執行重複工作的指令。\\
\subsection{語法 1 (要重複的程式碼只有一行時)}
\label{sec:org89bb8a1}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
for (初始值; 條件式; 更新值) 程式碼;
\end{lstlisting}

\subsection{語法 2 (要重複一行以上程式碼時)}
\label{sec:org029ae4a}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
for (初始值; 條件式; 更新值){
    程式碼一;
    程式碼二;
    ...
}
\end{lstlisting}

\textbf{初始值} 是進入迴圈一開始會執行的動作，而 \textbf{更新值} 則是執行完每次的迴圈要執行的動作，至於重複的次數則取決於 \textbf{條件式} 是否成立，只要 \textbf{條件式} 一直成立(其計算結果為 true)，則持續重複執行程式碼；所以要利用 \textbf{更新值} 來逐步修正，讓條件值有機會傳回 false。\\

\subsection{範例}
\label{sec:orgba33329}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;

int main() {
    for (int i = 1; i < 10; i++) {
        cout << "3 * " << i << " =  << 3*i << "endl;
    }
    return 0;
}
\end{lstlisting}

以上述程式為例，其程式執行的步驟如下：\\
\begin{enumerate}
\item 令迴圈變數 i=1，這個 \textbf{初始值} 只會執行一次(第5行)\\
\item 檢查 \textbf{條件式} i<10 是否成立，若不成立則跳出迴圈 ( 即跳至第8行 )\\
\item 若 \textbf{條作式} 成立，則執行第6行，輸出一行結果\\
\item 執行 \textbf{更新值} i++; ( 即 i=i+1; )將迴圈變數的值逐步加大，使其有機會違反 \textbf{條件式} (即結束迴圈)\\
\item 跳至 2. 的位置重複本步\\
\end{enumerate}

\subsection{練習}
\label{sec:org6e5eedf}
\begin{enumerate}
\item 輸入 n，輸出所有小於 n 的偶數．\\
\item 輸入 n，輸出所有小於 n 且可被 17 整除的數．\\
\item 輸入一數 N，輸出 1+2..+N\\
\end{enumerate}

\subsection{旗標變數}
\label{flag_variable}
有時我們希望能在迴圈的過程中判斷「某事是否曾發生過」，例如，「是否曾發現某數的因數？」、「連續輸入N個分數，判斷這N個分數中是否至少有一科不及格？」這是我們的思考方式就要稍做轉變。\\
\begin{enumerate}
\item 例題
\label{sec:org19e67b0}
小明買了N張單碼彩卷，問是否全部摃龜，若這N張彩卷中至少有一張中奬(號碼=77)，則輸出``NOT BAD''，否則輸出``QQ''。\\
\item 想法1
\label{sec:orgf86aed2}
面上述要求，for迴圈的初學者可能會想在for中直接判斷中奬與否，如下:\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n;
    int x;
    for (int i = 1; i <= n; i++) {
        cin >> x;
        if (x == 77) {
            cout << "NOT BAD\n";
        } else {
            cout << "QQ\n";
        }
    }
}
\end{lstlisting}

\begin{verbatim}
QQ
NOT BAD
QQ
\end{verbatim}

由上述結果可以發現，這並不是正確答案，很顯然應該把輸出判斷放在for的後面，那，要如何做到這點呢？\\
\item 想法2
\label{sec:org2c8f2eb}
另一種做法是，我們可以在for裡去計算中奬的次數，等到全部輸入完畢後，最後再統計一共有幾張中奬，這樣就可以解決上述問題：\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n;
    int x;
    int numOfWins = 0;
    for (int i = 1; i <= n; i++) {
        cin >> x;
        if (x == 77) {
            numOfWins++;
        }
    }
    if (numOfWins > 0) {
        cout << "NOT BAD\n";
    } else {
        cout << "QQ\n";
    }
}
\end{lstlisting}

\begin{verbatim}
NOT BAD
\end{verbatim}

回顧一下這個做法，其實我們會發現我們到最後根本不在乎有幾張彩卷中奬，我們只在乎有沒有中過奬，即，對我們而言，numOfWins其實只有兩種值:\\
\begin{itemize}
\item 0\\
\item 大於0\\
\end{itemize}
既然如此，其實以boolean變數來表示它會更為恰當。\\
\item 想法3
\label{sec:orgbce519d}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n;
    int x;
    bool iWin = false;
    for (int i = 1; i <= n; i++) {
        cin >> x;
        if (x == 77) {
            iWin = true;
        }
    }
    if (iWin) {
        cout << "NOT BAD\n";
    } else {
        cout << "QQ\n";
    }
}
\end{lstlisting}

\begin{verbatim}
NOT BAD
\end{verbatim}

這裡的iWin就是典型的Flag variable。\\
\end{enumerate}

\section{Nested For Loop}
\label{cpp_nested_for}
\subsection{語法}
\label{sec:org1f3d564}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
for (初始值1; 條件式1; 更新值1) {
    ...
    for (初始值2; 條件式2; 更新值2) {
        程式碼一;
        程式碼二;
        ...
    }
    ...
}
\end{lstlisting}
\subsection{範例}
\label{sec:org086a905}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;

int main() {
    int i, j;
    for (i = 0; i < 3; i++) {
        for (j = 1; j <= 5; j++) {
            cout << "*";
        }
        cout << endl;
    }
}
\end{lstlisting}

\begin{verbatim}
*****
*****
*****
\end{verbatim}


如同 if 可以有巢狀結構，for 的重複程式碼中也可以有 for 結構，上述的外層 for 迴圈(第6行到第11行)每重複一次，內層 for 迴圈(第7行到第9行)就會重複 5 次。\\
\subsection{課堂練習}
\label{sec:org4f41abd}
\begin{enumerate}
\item 輸入 x,y，輸出一由*構成、長為 x、寛為 y 的長方形，若 x=3, y=5，則輸出：
\label{sec:org2240be2}
\begin{verbatim}
***
***
***
***
***
\end{verbatim}
\item 輸入 n，若 n=5，輸出如下三角形:
\label{sec:org5f99f43}
\begin{verbatim}
*
**
***
****
*****
\end{verbatim}
\item 輸入 n，若 n=5，輸出如下三角形:
\label{sec:org66c1f62}
\begin{verbatim}
*****
****
***
**
*
\end{verbatim}
\item 輸入 n，若 n=5，輸出如下三角形:
\label{sec:orge0a4490}
\begin{verbatim}
1
22
333
4444
55555
\end{verbatim}
\end{enumerate}

\section{While}
\label{cpp_while}
\subsection{While}
\label{sec:org6940792}
\begin{enumerate}
\item 語法
\label{sec:org4c6519b}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
while( 條件式1 ) {
    程式碼1;
    程式碼2;
}
\end{lstlisting}
while 與 for 均為重複結構，比較起來，while 的語法結構更為簡單，但撰寫者要自行處理的事也更多一些。上述語法的執行流程為:\\
\begin{enumerate}
\item 若 while 後的 \textbf{條件 1} 成立，則執行一次大括號內的所有程式碼\\
\item 回到 1.\\
\end{enumerate}
由上述結構也可以看出，我們必須想辦法讓 \textbf{條件 1} 有機會不成立，否則這個 while 迴圈就會一直重複下去。\\
\item 範例 1
\label{sec:org573c1be}
以 while 模擬 for loop\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
##include <iostream>
using namespace std;
int main(int argc, char *argv[]) {
    int i;

    while (i<= 5) {
        cout << "This is a while test\n;"
        i++;
    }

    return 0;
}
\end{lstlisting}

\item 範例 2
\label{sec:org74e1082}
九九乘法表\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;

int main() {
    int i = 9;
    while (i > 0) {
        cout << "3 * " << i << " = " << 3*i << endl;
        i--;
    }
    return 0;
}
\end{lstlisting}

\begin{verbatim}
3 * 9 = 27
3 * 8 = 24
3 * 7 = 21
3 * 6 = 18
3 * 5 = 15
3 * 4 = 12
3 * 3 = 9
3 * 2 = 6
3 * 1 = 3
\end{verbatim}
\item 課堂練習
\label{sec:orgb34f6af}
\begin{itemize}
\item 輸入一整數 n，輸出\(\sum{n}\)，以 while 完成。\\
\end{itemize}
\end{enumerate}

\subsection{不固定次數的重複}
\label{sec:orgc78905c}
有些時候你想重覆執行某些動作，但是你又不確定會重覆多少次，典型的例子是輸入密碼，輸入錯誤後就應該重新輸入，作為系統設計者，你不會知道使用者會在第幾次輸入正確密碼，這就是 while 適合上場的時機\ldots{}.，例如:\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
輸入密碼;
while(密碼錯誤)
{
    輸入密碼;
}
\end{lstlisting}

\begin{enumerate}
\item 課堂練習
\label{sec:org65a6de9}
\begin{itemize}
\item 系統登入檢查:模擬作業系統登入畫面，進行使用者密碼檢查，當輸入輸入正確密碼後秀出畫面，否則持續要求輸入密碼\\
\item \(n!\)的值為 1*2*3*\ldots{}.*n，請問 n 最大到多少時，\(n!\)的人值才會開始超過 200000 ？\\
\end{itemize}
\end{enumerate}

\subsection{Do \ldots{} while}
\label{sec:orga70ae16}
有些狀況下，重複的次數 \textbf{至少} 要發生一次才行，例如前節中的密碼檢查，使用者至少要先輸入一次密碼，接下來系統才能針對密碼進行驗證，此時，do..while 會是一個比較理想的重複架構，其語法如下：\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
do {
    輸入密碼
} while (密碼錯誤);
\end{lstlisting}

比起前一節的 while，是不是更為精簡了呢\ldots{}.\\

\section{Array}
\label{cpp_arrays}
直至目前為止，我們學過宣告變數來儲存數值(int, double)，如果今天要計算全班資訊科成績平均(5 人)，也許我們可以用如下方式來計算:\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
int main(int argc, char *argv[]) {
    int cs1, cs2, cs3, cs4, cs5;
    std::cin >> cs1 >> cs2 >> cs3 >> cs4 >> cs5;

    double avg;
    avg = (cs1 + cs2 + cs3 + cs4 + cs5) / 5.0;

    std::cout << avg << endl;
    return 0;
}
\end{lstlisting}

but\ldots{}.如果全班有 50 個人呢？如果是要求全校的成績分佈呢?\\

各種程式語言為了因應這種大批資料的處理計算，都會有相對應的資料結構，C++的陣列(array)就是用來儲存大量資料的結構。\\
\subsection{宣告}
\label{sec:org8ffc899}
如果變數一樣，array 也要先宣告才能使用，其宣告方式如下：\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
資料型態 名稱[長度];
\end{lstlisting}

其中陣列長度必須為一編譯時期的常數，例如:\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
int number[10];    // 宣告 10 個元素的整數陣列
double score[10];  // 宣告 10 個元素的浮點數陣列
char ascii[10];    // 宣告 10 個元素的字元陣列
\end{lstlisting}

或是\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
int numOfStudent;
cin >> numOfStudent; //先確認人數
int score[numOfStudent];
\end{lstlisting}

\subsection{Assign value to Array}
\label{sec:orgfa78a43}
\begin{enumerate}
\item assign
\label{sec:orgb8083f3}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
int sc[5];
sc[0] = 51;
sc[1] = 44;
sc[2] = 93;
sc[3] = 20;
sc[4] = 100;
\end{lstlisting}

上述程式的執行結果如下所示：\\
\begin{figure}[htbp]
\centering
\includegraphics[width=300]{images/array.png}
\caption{\label{fig:Array}陣列儲存值(value)與 index 的關係}
\end{figure}

如上所示，宣告一陣列 sc，每個 int 並列儲存於陣列中，以 index 值(0\textasciitilde{}4)做為存取依據，因為 index 值為連續整數，所以我們可以很方便的套用 for-loop 來存取陣列內容,例如：\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
for (i = 0; i < 5; i++) {
    cout << sc[i] << endl;
}
\end{lstlisting}

\item 宣告時順便指定陣列初值
\label{sec:org20ab84b}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
int score[5] = {51, 44, 93, 20, 100};
\end{lstlisting}

\item cin
\label{sec:org40a82e9}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
int sc[5];
for (i = 0; i < 5; i++) {
    cin >> sc[i];
}
\end{lstlisting}
\end{enumerate}

\subsection{課堂練習}
\label{sec:org11d345b}
\begin{itemize}
\item 先輸入全班人數 N，接下來輸入 N 位學生的成績，存入一維陣列中，計算總分、平均。已知學生人數不超過 50 人。執行畫面需如下所示：\\
\end{itemize}
\begin{center}
\includegraphics[width=.9\linewidth]{images/array-3.jpg}
\end{center}
\begin{itemize}
\item 輸出上例中全班人數最高分之分數。\\
\end{itemize}
\subsection{其他類型的陣列}
\label{sec:org5315ff2}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
char ascii[5] = {'A', 'B', 'C', 'D', 'E'}; //字元陣列
bool flag[5] = {false, true, false, true, false};
\end{lstlisting}

\subsection{更方便的 for for array}
\label{sec:org0f2f40e}
C++ 11 提供了 for range 語法，可用於循序走訪陣列的任務\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;

int main() {
    int number[5] = {0, 1, 2, 3, 4};

    for(auto n : number) {
        cout << n << " ";
    }
    cout << endl;

    return 0;
}
\end{lstlisting}

\begin{verbatim}
0 1 2 3 4
\end{verbatim}
\subsection{index 為何由 0 開始?}
\label{sec:org2540741}
陣列索引值由 0 開始不是沒有原因的，陣列名稱儲存了陣列記憶體的首個位置的位址，而索引值表示陣列元素是相對於陣列首個記憶體位址的位移量（offset），位移的量與資料型態長度有關，如果是 int 整數，每次位移時是一個 int 整數的長度，例如在上例中 number[0] 索引值為 0 時，表示位移量為 0，自然就是指第一個元素，而 number[9] 就是指相對於首個元素的位移量為 9。\footnote{\href{https://openhome.cc/Gossip/CppGossip/OneDimArray.html}{陣列}\\}\\

\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;

int main() {
    int number[5] = {0, 1, 2, 3, 4};

    for(auto offset = begin(number); offset != end(number); offset++) {
        auto n = *offset;
        cout << offset << ": " << n << endl;
    }
    cout << endl;

    return 0;
}
\end{lstlisting}

\begin{verbatim}
0x7ffee0e24130: 0
0x7ffee0e24134: 1
0x7ffee0e24138: 2
0x7ffee0e2413c: 3
0x7ffee0e24140: 4
\end{verbatim}

上述程式中的 offset 為指標變數，其型代為 int*，代表記憶體的位址，若要取得該位址中的值，則以*offset 表示。若以圖形表示則為：\\
\begin{figure}[htbp]
\centering
\includegraphics[width=300]{images/address.png}
\caption{\label{fig:Memory-Value}陣列的記憶體位址(address)與儲存值(value)對照圖}
\end{figure}
\subsection{what you should not do with array}
\label{sec:org47a4627}
對一般變數，我們可以用以下 assign 方式將其值 assign 給其他變數：\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
int a = 20;
int b;
b = 20;
\end{lstlisting}

但是 array 不允許上述操作，如：\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
int ary1[5] = {0, 1, 3, 4, 5};
int ary2[5];
ary2 = ary1; //錯誤!!
\end{lstlisting}

如果要將某一陣列指定給另一個變數，只能透過迴圈逐一 assign:\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
int ary1[5] = {0, 1, 3, 4, 5};
int ary2[5];
for (i = 0; i < 5; i++) {
    ary2[i] = ary1[i];
}
\end{lstlisting}

\subsection{what you can do with array:}
\label{sec:org2fefba2}
\begin{enumerate}
\item sort
\label{sec:org0303c3b}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <algorithm>
#include <iostream>
using namespace std;
int main() {
    int number[] = {30, 12, 55, 31, 98, 11};
    // 排序
    sort(begin(number), end(number));
}
\end{lstlisting}
\item find
\label{sec:org7ec4313}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <algorithm>
#include <iostream>
using namespace std;
int main() {
    int number[] = {30, 12, 55, 31, 98, 11};

    cout << "輸入搜尋值：";
    int search = 0;
    cin >> search;

    int* addr = find(begin(number), end(number), search);
    cout << (addr != end(number) ? "找到" : "沒有")
         << "搜尋值"
         << endl;
}
\end{lstlisting}

\begin{verbatim}
輸入搜尋值：沒有搜尋值
\end{verbatim}

\item reverse
\label{sec:org8108c98}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <algorithm>
#include <iostream>
using namespace std;
int main() {
    int number[] = {30, 12, 55, 31, 98, 11};
    // 反轉
    reverse(begin(number), end(number));
}
\end{lstlisting}
\end{enumerate}

\subsection{2d array}
\label{sec:org8439b8d}
\begin{enumerate}
\item initialization
\label{sec:org59b8a58}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    int i, j;
    float grad[3][5];
    memset(grad, 0, sizeof(grad));

    for (i = 0; i < 3; i++) {
        for (j = 0; j < 5; j++) {
            cout << grad[i][j] << ", ";
        }
        cout << endl;
    }

    int x[5] = {0};
    for (i = 0; i < 5; i++) {
        cout << x[i];
    }
}
\end{lstlisting}

\begin{verbatim}
0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 
00000
\end{verbatim}
\end{enumerate}

\section{String}
\label{cpp_string}
\subsection{字串與字元陣列}
\label{sec:org9dbb22a}
\begin{itemize}
\item 字串(string)由一個一個的字元(char)組成，如``Hello world''、``TNFSH403''\\
\item 在C++裡，可以用 char[ ] 或 string 儲存字串\\
\end{itemize}
\subsection{儲存結構}
\label{sec:orgcb2e27a}
\begin{itemize}
\item 在下列程式中，字元陣列name1與字串name2的內容一模一樣，長度均為5個字元，但不管是以字元陣列(name1)或是以字串(name2)來儲存這五個字元，最後都有一個代表字串結尾的隱藏字元'$\backslash$0'來告訴電腦這個字串到此為止。\\
\item '$\backslash$0'的ASCII編號為0，是NULL、空集合的意思\\
\item 這個'$\backslash$0'不會被輸出，也不被算在字元陣列或是字串長度裡，所以不論是以strlen()或是length()都只看到長度為5。\\
\end{itemize}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include<iostream>
#include<string>
using namespace std;

int main()
{
    char name1[6] = {'T', 'N', 'F', 'S', 'H', '\0'};
    string name2 = "TNFSH";

    cout << name1 << ": " << strlen(name1) << endl;
    cout << name2 << ": " << name2.length() << endl;
    cout << "name1的第三個字元: " << name1[2] <<endl;
    cout << "name2的第三個字元: " << name2[2] <<endl;
    cout << name1[5] << endl;
    cout << name2[5] << endl;
    return 0;
}
\end{lstlisting}

\begin{verbatim}
TNFSH: 5
TNFSH: 5
name1的第三個字元: F
name2的第三個字元: F
 
 
\end{verbatim}
\subsection{宣告}
\label{sec:org2edf7d7}
\begin{itemize}
\item 宣告一個空的字元陣列要先告知預計會有幾個字元，字串則不用。\\
\item 如下例，雖然lastName輸入的字元不到不到20個，但cin會在最後面補上'$\backslash$0'，所以在cout時就只會輸出到'$\backslash$0'前面的字元\\
\end{itemize}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include<iostream>
using namespace std;

int main()
{
    char lastName[20];
    string firstName;

    cin >> lastName >> firstName;
    cout << "Your name is " << lastName << ", "<< firstName << endl;

    return 0;
}
\end{lstlisting}

\begin{verbatim}
Your name is James, Yen
\end{verbatim}
\subsection{輸入}
\label{sec:org050fd5e}
\begin{enumerate}
\item scanf()
\label{sec:org6bef0ae}
\begin{itemize}
\item C語言的輸入方式，用 scanf 讀取字串時，遇到空白字元便會結束。\\
\item 需include stdio.h\\
\end{itemize}
\lstset{breaklines=true,language=C,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <stdio.h>
int main() {
    char str[10];
    scanf("%s", str);
    printf("Your name: %s\n", str);
}
\end{lstlisting}

\begin{verbatim}
Your name: James
\end{verbatim}
\item cin
\label{sec:orge3678c6}
既可以讀字元，又可以讀字串。遇到空白字元或Enter便會結束。\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    string name1, name2;
    cin >> name1 >> name2;
    cout << "Welcome, " << name1 <<  ", " << name2 << endl;
}
\end{lstlisting}

\begin{verbatim}
Welcome, James, Yen
\end{verbatim}
\item cin.getline()
\label{sec:orge22a7b9}
\begin{itemize}
\item 可讀入空白，遇到Enter就結束輸入，需要include <string>\\
\item getline 函式使用兩個用逗號分隔的引數。第一個argument是要儲存字串的陣列的名稱。第二個argument是陣列的大小。當 cin.getline 語句執行時，cin 讀取的字元數將比該數字少一個，為 null 終止符留出空間。\\
\end{itemize}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
#include <string>
using namespace std;
int main() {
    char school[30];
    cin.getline(school, 30);
    cout << school << endl;
}

\end{lstlisting}

\begin{verbatim}
Tainan First Senior High Scho
\end{verbatim}

\item getline(cin, str)
\label{sec:org08d0129}
可以讀入空白，遇到Enter就結束輸入，需要include <string>\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
#include <string>
using namespace std;
int main() {
    string school;
    getline(cin, school);
    cout << school << endl;
}
\end{lstlisting}

\begin{verbatim}
Tainan First Senior High School
\end{verbatim}
\item gets(str)
\label{sec:org7cf7379}
可以讀入空白，遇到Enter就結束輸入。\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
    //string school;
    char school[30];
    gets(school);
    cout << school << endl;
}
\end{lstlisting}

\begin{verbatim}
Tainan First Senior High School
\end{verbatim}
\end{enumerate}
\subsection{輸出}
\label{sec:orgf4f3729}
\subsection{進階閱讀}
\label{sec:org38ffc30}
\begin{itemize}
\item \href{https://openhome.cc/Gossip/CppGossip/string1.html}{字元陣列與字串}\\
\item \href{https://www.796t.com/article.php?id=13952}{C++ cin.getline及getline()用法詳解}\\
\end{itemize}

\section{Function}
\label{cpp_functions}
將具有特定功能或經常重複使用的程式碼段落包裝成1個小單元，就稱之為function(函式)。使用function的好處：\\
\begin{enumerate}
\item 分割程式成為1個個的小模組，方便開發分工。\\
\item 程式碼可重複使用。\\
\item 程式可讀性高，且除錯或修改方便。\\
\end{enumerate}
\subsection{function declaration}
\label{sec:org720babf}
\begin{enumerate}
\item function的宣告語法
\label{sec:org3647866}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
傳回值的型態  function的名稱(參數1類別 參數1名稱, 參數2類別 參數2名稱, 參數3類別 參數3名稱, ...) {
    計算結果
    return 結果
}
\end{lstlisting}

\item function的宣告方式
\label{sec:orgec818d3}
\begin{enumerate}
\item 方式一:  直接將宣告與function內容一併寫出,置於main之前
\label{sec:org4e7dcd0}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
int add(int m,int n)
{
    return m+n;
}
void main()
{
    int a,b;
    cin >> a;
    cin >> b;
    cout << a << "+" << b << "=" << add(a,b);
}

\end{lstlisting}

\item 方式二: 先在main之前宣告,再將function實際內容置於main後面
\label{sec:org26a6ced}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
int add(int, int);
void main()
{
    int a,b;
    cin >> a;
    cin >> b;
    cout << a << "+" << b << "=" << add(a,b);
}
int add(int m,int n)
{
    return m+n;
}
\end{lstlisting}
\end{enumerate}
\end{enumerate}

\subsection{課堂練習}
\label{sec:org4beb940}
\begin{enumerate}
\item 定義一function max(int a, int b, int c): 該function有三個argument，傳出最大項，例：\\
cout << max(3, 5, 2) << endl;\\
\item 定義一function sos(double a, double b): 該參數有兩個argument，輸出其平方和，例：\\
cout << sos(4.5, 5.7) << endl;\\
\end{enumerate}
\subsection{引數 (Argument) vs. 參數 (Parameter)}
\label{sec:org67534d8}
\begin{itemize}
\item argument: 呼叫者傳給function的變數，如下例的a, b\\
\item parameter: function用來接住呼叫者傳進來的變數，如下例的x, y\\
\end{itemize}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
int mySum(int x, int y) {
    return x+y;
}

int main() {
    int a = 10, b = 20;
    cout << mySum(a, b) << endl;
}

\end{lstlisting}

\begin{verbatim}
30
\end{verbatim}
\subsection{void}
\label{sec:orgbd5b029}
void的字面意思是“無型別”，void* 則為“無型別指標”，void *可以指向任何型別的資料。\\
void真正發揮的作用在於：\\
\begin{itemize}
\item 對函式返回的限定；有些函式並不傳回值，這些函式必須宣告為void函式。\\
\item 對函式引數的限定。\\
\end{itemize}
\begin{enumerate}
\item 不傳回值的function
\label{sec:org01bcd22}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
void sayHi(string yourName) {
    cout << "Hi";
}

int main() {
    string name = "TNFSH";
    sayHi(name);
}
\end{lstlisting}

\begin{verbatim}
Hi
\end{verbatim}
\item 沒有parameter也不傳回值的的function
\label{sec:org0ba38ad}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
using namespace std;
void foo(void) {
    cout << "我就是閒\n";
}

int main() {
    foo();
}
\end{lstlisting}

\begin{verbatim}
我就是閒
\end{verbatim}
\item 沒有parameter v.s. parameter為void
\label{sec:org0e55fea}
\begin{itemize}
\item c: parameter為void表示不能有parameter，你硬傳argument進去都會出現error；parameter留空表示可以有很多個也可以沒有\\
\item c++: parameter為void或沒有都表示不能有，你硬要傳pargument進去都是error\\
\end{itemize}
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <stdio.h>
using namespace std;
void foo(void) {
}

void bar() {

}

int main() {
    foo(1);
    bar(1);
}
\end{lstlisting}
\end{enumerate}

\section{{\bfseries\sffamily TODO} Recursion}
\label{cpp_functions}
當一支function在自己的程式碼中又呼叫自己,會發生什麼事??\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include
#include <iostream>
using namespace std;
void selfcall(int n) {
    cout << n << endl;
    selfcall( n );
}
main () {
    int x=10;
    selfcall(x);
}
\end{lstlisting}

試著執行這支程式,驗證自己的想法,\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include
using namespace std;
void selfcall(int n) {
    cout << n << endl;
    selfcall(n+1);
}
main ()
{
        int x=1;
        selfcall(x);
}
\end{lstlisting}

\subsection{compute n!}
\label{sec:orgddcebd1}
\lstset{breaklines=true,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <iostream>
using namespace std;
int n(int x) {
    if (x==1) {
        return 1;
    } else {
        return x*n(x-1);
    }
}

int main() {
    int hi = 9;
    cout << n(8) << endl;
}

\end{lstlisting}

\section{{\bfseries\sffamily TODO} Struct}
\label{cpp_struct}
結構 (structure) 是一種複合型別 (derived data type)，用來表達由多個屬性組成的型別，而這些屬性可以是基本型別或是另一個複合型別所組成。\footnote{\href{https://michaelchen.tech/c-programming/struct/}{如何使用結構 (Struct)}\\} \textsuperscript{,}\,\footnote{\href{https://kopu.chat/2017/05/30/c-\%E8\%AA\%9E\%E8\%A8\%80\%EF\%BC\%9A\%E7\%B5\%90\%E6\%A7\%8B\%EF\%BC\%88struct\%EF\%BC\%89\%E8\%87\%AA\%E8\%A8\%82\%E4\%B8\%8D\%E5\%90\%8C\%E8\%B3\%87\%E6\%96\%99\%E5\%9E\%8B\%E6\%85\%8B\%E7\%B6\%81\%E4\%B8\%80\%E8\%B5\%B7/}{C 語言：結構（struct）自訂不同資料型態綁一起}\\}\\
\lstset{breaklines=true,language=cpp,label= ,caption= ,captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
#include <iostream>
#include <string.h>
using namespace std;

struct student{ //名稱為student的結構
    int id; //學號為整數型
    char name[20]; //姓名為字元陣列
    char sex; //性別為字元型
    float score; //成績為浮點型
};

int main() {
    student s1, s2, s3;
    s1.id = 90001;
    strcpy(s1.name, "James, Yen");
    s1.sex = 'F';
    s1.score = 88.88;
}

\end{lstlisting}

\section{{\bfseries\sffamily TODO} STL}
\label{sec:orgf69c929}
\end{document}
